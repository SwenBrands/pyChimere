#!/usr/bin/env python

# This script loads the climatological mean value for the eight varialbles currently not provided by CAMS/C-IFS from the MACC reanalysis data provided by the CHIMERE
# developers and interpolates from the 1.125 degree grid of the reanalysis to the 40 km grid of C-IFS. This is done on the global scale. Variables are saved in nc format
# one file per variable and month. The .nc files generated by this script are called by <postprocess_cams.py>

#from netCDF4 import Dataset
import xarray as xr
import numpy as np
import pandas as pd
import sys
import dask
from mpl_toolkits import basemap

tardate='20171217'
tarhour='00'

#dimensions of the CAMS input files are (latitude: 451, level: 60, longitude: 900, time: 11)
source = '/mnt/lustre/scratch//home/cesga/orballo/OP/DATOS/CICC/chimere2017r4/MACC/'+tardate
source_clim = '/mnt/lustre/scratch//home/cesga/orballo/OP/DATOS/CICC/chimere2017r4/MACC/clim_global'
outpath = '/mnt/lustre/scratch//home/cesga/orballo/OP/DATOS/CICC/chimere2017r4/MACC/myclim'
months=('01','02','03','04','05','06','07','08','09','10','11','12')
variables = ('BIGALK','BIGENE','CH3CHO','GLYOXAL','H2O2','NH3','TOLUENE','C10H16','TEMP') #set variable name as defined in CAMS
#months=('01','02')
#variables = ('BIGALK','BIGENE') #set variable name as defined in CAMS

### EXECUTE #############################################################
for ii in xrange(len(variables)):
    #load file in cache
    tarvar = variables[ii]
    srcfile = source+'/z_cams_c_ecmf_'+tardate+tarhour+'0000_prod_fc_ml_*_go3.nc' #all forecast hours of an example 3d varible, needed to define the target dates, latitudes and longitudes    
    print('loading files '+srcfile)        
    nc = xr.open_mfdataset(srcfile, concat_dim='time', engine='netcdf4')
    
    #load and process lat and lon
    lons = nc.variables['longitude'][:]
    lons = lons.values
    lons_ind_west = np.where(lons > 180)
    lons_ind_east = np.where((lons >= 0) & (lons <= 180))
    lons_ind = np.squeeze(np.concatenate((lons_ind_west,lons_ind_east),axis=1))
    lons = nc.variables['longitude'][lons_ind]    
    lons = lons.values
    
    #change format of the longtitudes to -180 to 180
    lons_ind_shift = np.where(lons > 180)
    lons[lons_ind_shift] = lons[lons_ind_shift]-360   
    
    lats = nc.variables['latitude'][:]
    lats = lats.values    
    lats_ind = np.argsort(lats)
    lats = nc.variables['latitude'][lats_ind] #bring the lats into ascending order
    lats = lats.values
    
    levs = nc.variables['level'][:]    
    
    ##get indices for target region
    #latsind=np.squeeze(np.array(np.where((lats > 30) & (lats < 60))))
    #lonsind=np.squeeze(np.array(np.where((lons > -20) & (lons < 10))))
    ##reload lats and lonsw with indices
    #lats = nc.variables['latitude'][latsind]
    #lons = nc.variables['longitude'][lonsind]
        
    #load and process the time variable
    dates = nc.variables['time']
    dates = str(dates.values)
    dates = dates.replace("-", "")
    dates = dates.replace("\n", "")
    dates = dates.replace("\n", "")
    dates = dates.replace("T", ".")
    dates = dates.replace(":00:00.000000000","")
    dates = dates.replace(" ",",")
    dates = dates.replace("[","")
    dates = dates.replace("]","")
    dates = dates.replace("'","")
    dates = dates.split(',')
    
    for i in xrange(len(dates)):
        dates[i] = dates[i][0:8]
        
    dates=[float(i) for i in dates]
    for i in xrange(len(dates)):
        dates[i] = dates[i]+0.125*i
    
    nc.close()    
    
    #load the climatological data process the data
    for mm in xrange(len(months)):      
        climfile = source_clim+'/gasmet_0000'+months[mm]+'.nc'
        print('loading and interpolating climatological mean values from '+climfile)
        nc_clim = xr.open_mfdataset(climfile, engine='netcdf4')
        lats_clim = nc_clim.variables['lat'][:]
        lats_ind_clim = np.argsort(lats_clim)
        lats_clim = nc_clim.variables['lat'][lats_ind_clim]
        lats_clim = lats_clim.values
        
        lons_clim = nc_clim.variables['lon'][:]
        lons_clim = lons_clim.values        
        lons_ind_west_clim = np.where(lons_clim > 180)
        lons_ind_east_clim = np.where((lons_clim >= 0) & (lons_clim <= 180))
        lons_ind_clim = np.squeeze(np.concatenate((lons_ind_west_clim,lons_ind_east_clim),axis=1))
        lons_clim = nc_clim.variables['lon'][lons_ind_clim]
        lons_clim = lons_clim.values
        data_clim = nc_clim.variables[tarvar][:,:,lats_ind_clim,lons_ind_clim]
        data_clim = data_clim.values
        
        #change format of the longtitudes to -180 to 180        
        lons_ind_shift_clim = np.where(lons_clim > 180)
        lons_clim[lons_ind_shift_clim] = lons_clim[lons_ind_shift_clim]-360
                
        levs_clim = nc_clim.variables['lev'][:] #load 3d levels
        time_clim = nc_clim.variables['time'][:] #load 3d levels
        
        ##interpolate climatological mean data to finer grid defined by lats and lons
        [lons_mesh,lats_mesh] = np.meshgrid(lons,lats)
        data_out = np.zeros((len(time_clim), len(levs), len(lats), len(lons)))
        print('info: starting interpolation...')
        for tt in xrange(len(time_clim)):
            for ll in xrange(len(levs_clim)):
                data_out[tt,ll,:,:] = basemap.interp(data_clim[tt,ll,:,:], lons_clim, lats_clim, lons_mesh, lats_mesh)
        
        ## then bring latitudes longitudes and data to the original format (lats ascending from 90 to -90, lons from 0 to 360)
        lons_ind_east_org = np.where(lons >= 0)
        lons_ind_west_org = np.where(lons < 0)
        lons_ind_org = np.squeeze(np.concatenate((lons_ind_east_org,lons_ind_west_org),axis=1))
        lats_ind_org = np.argsort(lats*-1)
        data_out = data_out[:,:,:,lons_ind_org]
        data_out = data_out[:,:,lats_ind_org,:]
        data_out = np.squeeze(data_out) #turn to 3d variable
        #data_out = np.tile(data_out,(len(dates),1,1,1))
        lons_end = lons[lons_ind_org]
        lats_end = lats[lats_ind_org]
        lons_ind_end = np.where(lons_end < 0)
        lons_end[lons_ind_end] = lons_end[lons_ind_end]+360        
                 
        #define output file
        ##in case output is 4d
        #output = xr.DataArray(data_out, coords=[dates[0], levs, np.double(lats_end), np.double(lons_end)], dims=['time', 'lev', 'lat', 'lon'], name=variables[ii])
        #in case output is 3d
        output = xr.DataArray(data_out, coords=[levs, np.double(lats_end), np.double(lons_end)], dims=['lev', 'lat', 'lon'], name=variables[ii])
            
        ##then save to netCDF
        outputfile = outpath+'/clim_'+variables[ii]+'_'+months[mm]+'.nc'
        output.to_netcdf(outputfile,mode='w',format='NETCDF3_64BIT')
        output.close()
        del output
        #del data_out
        nc_clim.close()
